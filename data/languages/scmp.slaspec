# Copyright 2025 Sigurdur Asgeirsson <siggi@sort.is>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Sleigh specification file for the SC/MP Processor

# This processor has a couple of interesting quirks.
# 1. During the execution of any instruction, the PC register points to the last
#    byte fetched, whether that byte is an opcode or a displacement.
# 2. PC is incremented before fetching the next instruction.
#    This means that any instruction that modifies PC effectively targets the
#    byte after the value that's assigned to PC.
# 3. Reset zeros PC, but because PC is incremented before instruction fetch,
#    the RST routine actually starts at address 0x0001.

define endian=big;
define alignment=1;

define space ram     type=ram_space      size=2  default;

define space register type=register_space size=1;

define register offset=0x00 size=1 [ AC SR E SERIAL ];
define register offset=0x10 size=2 [ PC P1 P2 P3 ];

# Flag bits
define bitrange
  CYL=SR[7,1]   # CY/L: Carry/Link
  OV=SR[6,1]    # OV: Overflow
  SB=SR[5,1]    # SB: Sense Bit B
  SA=SR[4,1]    # SA: Sense Bit A`
  IE=SR[3,1]    # IE: Interrupt Enable
  F2=SR[2,1]    # F2: User Flag 2
  F1=SR[1,1]    # F1: User Flag 1
  F0=SR[0,1]    # F0: User Flag 0
;

# Serial in/out flags.
define bitrange
  SOUT=SERIAL[7,1]
  SIN=SERIAL[0,1]
;


define token opbyte (8)
  op0_7     = (0,7)
  op2_7     = (2,7)
  op3_7     = (3,7)
  op_m 	   = (2,2)
  op_ptr    = (0,1)
;

define token data8 (8)
  imm8		= (0,7)
  disp8	= (0,7) signed
;

attach variables [ op_ptr ] [ PC P1 P2 P3 ];

# Define special pcodeop that adds a displacement to a pointer.
define pcodeop addDispl;

macro dispEa(dst, reg, disp) {
  dst = addDispl(reg, disp);
}

macro autoIndexedEa(dst, ptr, disp) {
  local d:2 = sext(disp);
  local tmp:2 = addDispl(ptr, d);

  dst = ptr;
  if (disp s>= 0)
    goto <post_incr>;

  # The pre-decrement case returns the new EA.
  dst = tmp;

<post_incr>
  # Update the ptr register to the new value in either case.
  ptr = tmp;
}

# Because inst_next doesn't wrap around properly,
# use a special macro to deal with that.
# Note also that the reference PC is not inst_next,
# but rather the address of the displacement.
macro dispPc(dst, disp) {
  local start:2 = inst_start;
  local tmp:2 = sext(disp) + 1;
  dst = addDispl(start, tmp);
}

# Because of the increment prior to instruction fetch
# the JMP instructions need an extra count.
macro dispPcJmp(dst, disp) {
  local start:2 = inst_start;
  local tmp:2 = sext(disp) + 2;
  dst = addDispl(start, tmp);
}

macro additionWithCarry(op) {
    local carryIn = CYL;
    local tmpResult = AC + op;

    CYL = carry(AC, op) || carry(tmpResult, carryIn);
    OV = scarry(AC, op) ^^ scarry(tmpResult, carryIn);

    AC = tmpResult + carryIn;
}

macro decimalAddition(op) {
  local rl:1 = AC & 0x0F;
  local rh:1 = AC >> 4;
  local opl:1 = op & 0x0F;
  local oph:1 = op >> 4;

  # Add in the carry.
  opl = opl + CYL;

  rl = rl + opl;
  if (rl <= 0x09)
    goto <no_half_carry>;

  rl = rl - 10;
  oph = oph + 1;

  <no_half_carry>

  rh = rh + oph;
  if (rh <= 9)
    goto <no_full_carry>;

  rh = rh - 10;
  CYL = 1;
  goto <out>;

  <no_full_carry>

  CYL = 0;

  <out>
  AC = (rh << 4) | rl;
}

# PC-relative.
EA: loc is op_m = 0 & op_ptr = 0; imm8 != 0x80 & disp8
    [ loc = (inst_start & 0xF000) | ((inst_start + 1 + disp8) & 0x0FFF); ] {
  local ret:2;
  dispPc(ret, disp8:1);
  export ret;
}

# Pointer-relative.
EA: disp8(op_ptr) is op_m = 0 & op_ptr; imm8 != 0x80 & disp8 {
  local tmp:2 = sext(disp8:1);
  local ret:2 = addDispl(op_ptr, tmp);
  export ret;
}

# Auto-indexed.
# The op_ptr constraint excludes op code 0xCC, which would be the
# nonsensical STI.
EA: @disp8(op_ptr) is op_m = 1 & op_ptr &
    (op_ptr = 1 | op_ptr = 2 | op_ptr = 3); imm8 != 0x80 & disp8 {
  local ret:2 = op_ptr:2;
  autoIndexedEa(ret, op_ptr, disp8:1);
  export ret;
}

# Special cases for E-relative.
EA: E(op_ptr) is op_m = 0 & op_ptr & E; imm8 = 0x80 {
  local tmp:2 = sext(E);
  local ret:2 = addDispl(op_ptr, tmp);
  export ret;
}

EA: @E(op_ptr) is op_m = 1 & op_ptr & E; imm8 = 0x80 {
  local ret:2;
  autoIndexedEa(ret, op_ptr, E);
  export ret;
}

PTR: loc is op_ptr = 0; disp8
    [ loc = (inst_start & 0xF000) | ((inst_start + 1 + disp8) & 0x0FFF); ] {
  local ret:2;
  dispPc(ret, disp8:1);
  export ret;
}

PTR: disp8(op_ptr) is op_ptr; disp8 {
  local tmp:2 = sext(disp8:1);
  local ret:2 = addDispl(op_ptr, tmp);
  export ret;
}

# PC-relative labels reference the actual destination, which
# is one larger than the address displayed in e.g. DID.
# The effective PC returned is also one larger than the effective
# address to allow the instruction stream to goto the right
# address without a second adjustment in each JMP instruction.
PTRJmp: loc is op_ptr = 0; disp8
    [ loc = (inst_start & 0xF000) | ((inst_start + 2 + disp8) & 0x0FFF); ] {
  local ret:2;
  dispPcJmp(ret, disp8:1);
  export ret;
}

PTRJmp: disp8(op_ptr) is op_ptr; disp8 {
  local tmp:2 = disp8 + 1;
  local ret:2;
  dispEa(ret, op_ptr, tmp);
  export ret;
}


# Instructions in order of appearance in the
# SC/MP Programming and Assembler Manual.
:LD EA is op3_7 = 0x18 ... & EA {
  AC = *EA;
}

:ST EA is op3_7 = 0x19 ... & EA {
  *EA = AC;
}

:AND EA is op3_7 = 0x1A ... & EA {
  AC = AC & *EA;
}

:OR EA is op3_7 = 0x1B ... & EA {
  AC = AC | *EA;
}

:XOR EA is op3_7 = 0x1C ... & EA {
  AC = AC ^ *EA;
}

:DAD EA is op3_7 = 0x1D ... & EA {
  decimalAddition(*EA);
}

:ADD EA is op3_7 = 0x1E ... & EA {
  additionWithCarry(*EA);
}

:CAD EA is op3_7 = 0x1F ... & EA {
  additionWithCarry(~(*EA));
}

:ILD PTR is op2_7 = 0x2A ... & PTR {
  local ea:2 = PTR;
  *:1 ea = *:1 ea + 1;
  AC = *:1 ea;
}

:DLD PTR is op2_7 = 0x2E ... & PTR {
  local ea:2 = PTR;
  *:1 ea = *:1 ea - 1;
  AC = *:1 ea;
}

:LDI imm8 is op0_7 = 0xC4; imm8 {
  AC = imm8;
}

:ANI imm8 is op0_7 = 0xD4; imm8 {
  AC = AC & imm8;
}

:ORI imm8 is op0_7 = 0xDC; imm8 {
  AC = AC | imm8;
}

:XRI imm8 is op0_7 = 0xE4; imm8 {
  AC = AC ^ imm8;
}

:DAI imm8 is op0_7 = 0xEC; imm8 {
  decimalAddition(imm8);
}

:ADI imm8 is op0_7 = 0xF4; imm8 {
  additionWithCarry(imm8);
}

:CAI imm8 is op0_7 = 0xFC; imm8 {
  additionWithCarry(~imm8);
}

:JMP PTRJmp is op2_7 = 0x24 ... & PTRJmp {
  goto [PTRJmp];
}

:JP PTRJmp is op2_7 = 0x25 ... & PTRJmp {
  if (AC & 0x80)
    goto <nojmp>;

  goto [PTRJmp];
  <nojmp>
}

:JZ PTRJmp is op2_7 = 0x26 ... & PTRJmp {
  if (AC != 0)
    goto <nojmp>;

  goto [PTRJmp];
  <nojmp>
}

:JNZ PTRJmp is op2_7 = 0x27 ... & PTRJmp {
  if (AC == 0)
    goto <nojmp>;
  goto [PTRJmp];
  <nojmp>
}

:DLY imm8 is op0_7 = 0x8F; imm8 {
  # DLY is a NOP for disassembly.
  goto inst_next;
}

:LDE is op0_7 = 0x40 {
  AC = E;
}

:XAE is op0_7 = 0x01 {
  local tmp:1 = E;
  E = AC;
  AC = tmp;
}

:ANE is op0_7 = 0x50 {
  AC = AC & E;
}

:ORE is op0_7 = 0x58 {
  AC = AC | E;
}

:XRE is op0_7 = 0x60 {
  AC = AC ^ E;
}

:DAE is op0_7 = 0x68 {
  decimalAddition(E);
}

:ADE is op0_7 = 0x70 {
  additionWithCarry(E);
}

:CAE is op0_7 = 0x78 {
  additionWithCarry(~E);
}

# TODO(siggi): Special case for PC!
:XPAL op_ptr is op2_7 = 0x0C & op_ptr {
  local tmp:1 = op_ptr[0,8];
  op_ptr[0,8] = AC;
  AC = tmp;
}

# TODO(siggi): Special case for PC!
:XPAH op_ptr is op2_7 = 0x0D & op_ptr {
  local tmp:1 = op_ptr[8,8];
  op_ptr[8,8] = AC;
  AC = tmp;
}

:XPPC op_ptr is op2_7 = 0x0F & op_ptr {
  # PC is incremented after the assignment, so the effective
  # PC is one larger than op_ptr.
  local tmp:2 = addDispl(op_ptr, 1:2);
  op_ptr = inst_start;

  goto [tmp];
}

:SIO is op0_7 = 0x19 {
  SOUT = E[0, 1];
  E = (E >> 1) | (SIN << 7);
}

:SR is op0_7 = 0x1C {
  AC = AC >> 1;
}

:SRL is op0_7 = 0x1D {
  AC = (AC >> 1) | (CYL << 7);
}

:RR is op0_7 = 0x1E {
  AC = (AC >> 1) | (AC << 7);
}

:RRL is op0_7 = 0x1F {
  local tmp:1 = AC;
  AC = (AC >> 1) | (CYL << 7);
  CYL = tmp & 0x01;
}

:HALT is op0_7 = 0x00 {
  # HALT is a NOP for disassembly.
  goto inst_next;
}

:CCL is op0_7 = 0x02 {
  CYL = 0;
}

:SCL is op0_7 = 0x03 {
  CYL = 1;
}

:DINT is op0_7 = 0x04 {
  IE = 0;
}

:IEN is op0_7 = 0x05 {
  IE = 1;
}

:CSA is op0_7 = 0x06 {
  AC = SR;
}

:CAS is op0_7 = 0x07 {
  SR = AC;
}

:NOP is op0_7 = 0x08 {
  goto inst_next;
}
