# Sleigh specification file for SC/MP Processor

define endian=big;
define alignment=1;

define space ram     type=ram_space      size=2  default;

define space register type=register_space size=1;

define register offset=0x00 size=1 [ AC SR E ];
define register offset=0x10 size=2 [ PC P1 P2 P3 ];

# Flag bits
@define CYL_flag  "SR[7,1]"   # CY/L: Carry/lINK
@define OV_flag   "SR[6,1]"   # OV: Overflow
@define SB_flag   "SR[5,1]"   # SB: Sense Bit B
@define SA_flag   "SR[4,1]"   # SA: Sense Bit 1
@define IE_flag   "SR[3,1]"   # IE: Interrupt Enable
@define F2_flag   "SR[2,1]"   # F2: User Flag 2
@define F1_flag   "SR[1,1]"   # F1: User Flag 1
@define F0_flag   "SR[0,1]"   # F0: User Flag 0

define token opword (16)
  w_opshort   = (11, 15)
  w_m         = (10, 10)
  w_ptr       = (8, 9)
  w_reg       = (8, 9)
  w_imm8      = (0, 7)
  w_disp8     = (0, 7) signed
;

define token opbyte (8)
   op3_7     = (3,7)
   op_m 	   = (2,2)
   op_ptr    = (0,1)
;

define token data8 (8)
   imm8		= (0,7)
   disp8	= (0,7) signed
;

attach variables [ w_ptr ] [ PC P1 P2 P3 ];

# PC-relative.
EA: loc is w_m = 0 & w_ptr = 0 & w_disp8 != 0x80; w_disp8 [ loc = inst_next + w_disp8; ] {
  local ret:2 = (inst_next + w_disp8) & 0xFFF;
  export ret;
}

# Pointer-relative.
EA: w_disp8(w_ptr) is w_m = 0; w_disp8; w_ptr {
  local ret:2 = (w_ptr + w_disp8) & 0xFFF;
  export ret;
}

# Special case for E-relative.
EA: "E"(w_ptr) is w_m = 0 & w_disp8 = 0x80; w_ptr {
  local ret:2 = (w_ptr + sext(E)) & 0xFFF;
  export ret;
}

:LD EA is w_opshort = 0x18; EA {
  AC = *EA;
}

:ST EA is w_opshort = 0x19; EA {
  *EA = AC;
}

:AND EA is w_opshort = 0x1A; EA {
  AC = AC & *EA;
}

:OR EA is w_opshort = 0x1B; EA {
  AC = AC | *EA;
}

:XOR EA is w_opshort = 0x1C; EA {
  AC = AC ^ *EA;
}

:DAD EA is w_opshort = 0x1D; EA {
  # TODO(siggi): writeme!
  AC = AC ^ *EA;
}

:ADD EA is w_opshort = 0x1E; EA {
  # TODO(siggi): fixme!
  AC = AC + *EA;
}

:CAD EA is w_opshort = 0x1F; EA {
  # TODO(siggi): fixme!
  AC = AC + *EA;
}
