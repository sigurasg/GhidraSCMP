# Copyright 2025 Sigurdur Asgeirsson <siggi@sort.is>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Sleigh specification file for the SC/MP Processor

define endian=big;
define alignment=1;

define space ram     type=ram_space      size=2  default;

define space register type=register_space size=1;

define register offset=0x00 size=1 [ AC SR E ];
define register offset=0x10 size=2 [ PC P1 P2 P3 ];

# Flag bits
@define CYL_flag  "SR[7,1]"   # CY/L: Carry/lINK
@define OV_flag   "SR[6,1]"   # OV: Overflow
@define SB_flag   "SR[5,1]"   # SB: Sense Bit B
@define SA_flag   "SR[4,1]"   # SA: Sense Bit 1
@define IE_flag   "SR[3,1]"   # IE: Interrupt Enable
@define F2_flag   "SR[2,1]"   # F2: User Flag 2
@define F1_flag   "SR[1,1]"   # F1: User Flag 1
@define F0_flag   "SR[0,1]"   # F0: User Flag 0


define token opbyte (8)
   op0_7     = (0,7)
   op2_7     = (2,7)
   op3_7     = (3,7)
   op_m 	   = (2,2)
   op_ptr    = (0,1)
;


define token data8 (8)
   imm8		= (0,7)
   disp8	= (0,7) signed
;

attach variables [ op_ptr ] [ PC P1 P2 P3 ];

# PC-relative.
EA: loc is op_m = 0 & op_ptr = 0 ; imm8 != 0x80 & disp8 [ loc = (inst_next + disp8) & 0xFFF; ] {
  local ret:2 = (inst_next + disp8) & 0xFFF;
  export ret;
}

# Pointer-relative.
EA: disp8(op_ptr) is op_m = 0 & op_ptr; imm8 != 0x80 & disp8 {
  local ret:2 = (op_ptr + disp8) & 0xFFF;
  export ret;
}

# Auto-indexed.
EA: @disp8(op_ptr) is op_m = 1 & op_ptr; imm8 != 0x80 & disp8 {
  # TODO(siggi): Deal with pre-decrement and post-increment.
  local ret:2 = (op_ptr + disp8) & 0xFFF;
  op_ptr = ret;
  export ret;
}

# Special cases for E-relative.
EA: E(op_ptr) is op_m = 0 & op_ptr & E ; imm8 = 0x80 {
  local ret:2 = (op_ptr + sext(E)) & 0xFFF;
  export ret;
}

EA: @E(op_ptr) is op_m = 1 & op_ptr & E; imm8 = 0x80 {
  # TODO(siggi): Deal with pre-decrement and post-increment.
  local ret:2 = (op_ptr + sext(E)) & 0xFFF;
  op_ptr = ret;
  export ret;
}


# Instructions in order of appearance in the
# SC/MP Programming and Assembler Manual.
:LD EA is op3_7 = 0x18 ... & EA {
  AC = *EA;
}

:ST EA is op3_7 = 0x19 ... & EA {
  *EA = AC;
}

:AND EA is op3_7 = 0x1A ... & EA {
  AC = AC & *EA;
}

:OR EA is op3_7 = 0x1B ... & EA {
  AC = AC | *EA;
}

:XOR EA is op3_7 = 0x1C ... & EA {
  AC = AC ^ *EA;
}

:DAD EA is op3_7 = 0x1D ... & EA {
  # TODO(siggi): writeme!
  AC = AC ^ *EA;
}

:ADD EA is op3_7 = 0x1E ... & EA {
  # TODO(siggi): fixme!
  AC = AC + *EA;
}

:CAD EA is op3_7 = 0x1F ... & EA {
  # TODO(siggi): fixme!
  AC = AC + *EA;
}

:ILD loc is op2_7 = 0x2A & op_ptr = 0 & op_ptr ; disp8 [ loc = (inst_next + disp8) & 0xFFF; ]{
  local ea:2 = (inst_next + disp8) & 0xFFFF;
  *:1 ea = *:1 ea + 1;
  AC = *:1 ea;
}

:ILD disp8(op_ptr) is op2_7 = 0x2A & op_ptr ; disp8 {
  local ea:2 = (op_ptr + disp8) & 0xFFFF;
  *:1 ea = *:1 ea + 1;
  AC = *:1 ea;
}

:DLD loc is op2_7 = 0x2E & op_ptr = 0 & op_ptr ; disp8 [ loc = (inst_next + disp8) & 0xFFF; ]{
  local ea:2 = (inst_next + disp8) & 0xFFFF;
  *:1 ea = *:1 ea - 1;
  AC = *:1 ea;
}

:DLD disp8(op_ptr) is op2_7 = 0x2E & op_ptr ; disp8 {
  local ea:2 = (op_ptr + disp8) & 0xFFFF;
  *:1 ea = *:1 ea - 1;
  AC = *:1 ea;
}

:LDI imm8 is op0_7 = 0xC4 ; imm8 {
  AC = imm8;
}

:ANI imm8 is op0_7 = 0xD4 ; imm8 {
  AC = AC & imm8;
}

:ORI imm8 is op0_7 = 0xDC ; imm8 {
  AC = AC | imm8;
}

:XRI imm8 is op0_7 = 0xE4 ; imm8 {
  AC = AC ^ imm8;
}

:DAI imm8 is op0_7 = 0xEC ; imm8 {
  # TODO(siggi): Implement.
  AC = imm8;
}

:ADI imm8 is op0_7 = 0xF4 ; imm8 {
  # TODO(siggi): Implement carry.
  AC = AC + imm8;
}

:CAI imm8 is op0_7 = 0xFC ; imm8 {
  # TODO(siggi): Implement.
  AC = imm8;
}

@if 0


JMP
JP
JZ
JNZ

DLY
@endif

:LDE is op0_7 = 0x40 {
  AC = E;
}

@if 0
XAE
ANE
ORE
XRE
DAE
ADE
CAE
@endif

:XPAL op_ptr is op2_7 = 0x0C & op_ptr {
  # TODO(siggi): Implement.
}

:XPAH op_ptr is op2_7 = 0x0D & op_ptr {
  # TODO(siggi): Implement.
}

:XPPC op_ptr is op2_7 = 0x0F & op_ptr {
  # TODO(siggi): Implement.
}

@if 0
SIO
SR
SRL
RR
RRL

HALT
CCL
SCL
DINT
IEN
CSA
CAS

@endif

:NOP is op0_7 = 0x08 {
  goto inst_next;
}
